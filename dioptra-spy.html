<!DOCTYPE html>
<!--
  DioptraSpy
  Copyright (C) 2025 Kanarath

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dioptra Spy</title>

    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìç</text></svg>"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
    />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0"
    />

    <style>
      :root {
        --header-height: 50px;
        --sidebar-width: 320px;
        --inspector-width: 350px;
        --bg-color: #f8f9fa;
        --border-color: #dee2e6;
        --text-color: #212529;
        --primary-color: #0d6efd;
        --white: #fff;
        --shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
        --tran-speed: 0.3s;
      }
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        overflow: hidden;
        background-color: var(--bg-color);
      }
      #header {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: var(--header-height);
        background: var(--white);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        box-sizing: border-box;
        z-index: 1001;
      }
      #sidebar {
        position: fixed;
        top: var(--header-height);
        left: 0;
        width: var(--sidebar-width);
        height: calc(100% - var(--header-height));
        background: var(--white);
        border-right: 1px solid var(--border-color);
        z-index: 1000;
        transform: translateX(calc(-1 * var(--sidebar-width)));
        transition: transform var(--tran-speed) ease;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
      }
      #sidebar.open {
        transform: translateX(0);
      }
      #main-content {
        width: 100%;
        height: 100%;
        padding-top: var(--header-height);
        box-sizing: border-box;
        position: relative;
        transition: padding-left var(--tran-speed) ease,
          padding-right var(--tran-speed) ease;
      }
      #sidebar.open ~ #main-content {
        padding-left: var(--sidebar-width);
      }
      #inspector.open ~ #main-content {
        padding-right: var(--inspector-width);
      }
      #map {
        height: 100%;
        width: 100%;
      }
      #map.pin-drop-mode,
      #map.measure-mode,
      #map.range-mode {
        cursor: crosshair;
      }
      #map.connection-mode {
        cursor: cell;
      }

      #inspector {
        position: fixed;
        top: var(--header-height);
        right: 0;
        width: var(--inspector-width);
        height: calc(100% - var(--header-height));
        background: var(--white);
        border-left: 1px solid var(--border-color);
        z-index: 1000;
        transform: translateX(var(--inspector-width));
        transition: transform var(--tran-speed) ease;
        display: none;
        flex-direction: column;
      }
      #inspector.open {
        transform: translateX(0);
        display: flex;
      }
      #inspector-content {
        padding: 20px;
        flex-grow: 1;
        overflow-y: auto;
      }
      #inspector-placeholder {
        color: #6c757d;
        text-align: center;
        padding-top: 50px;
      }
      #details-thumbnail {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        margin-bottom: 20px;
        object-fit: cover;
        cursor: pointer;
      }

      .inspector-group {
        margin-bottom: 20px;
      }
      .inspector-group label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        font-weight: 600;
        color: #6c757d;
        text-transform: uppercase;
      }
      .inspector-group input,
      .inspector-group textarea,
      .inspector-group select {
        width: 100%;
        box-sizing: border-box;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 8px 10px;
        font-family: inherit;
        font-size: 14px;
        resize: none;
      }
      #details-notes,
      #general-notes {
        resize: vertical;
        min-height: 120px;
      }

      .header-left,
      .header-right {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .logo {
        font-size: 1.2rem;
        font-weight: 600;
      }
      .logo span {
        color: var(--primary-color);
      }
      .icon-button {
        background: none;
        border: none;
        cursor: pointer;
        padding: 5px;
        border-radius: 50%;
        display: inline-flex;
        transition: background-color 0.2s;
      }
      .icon-button:hover,
      .icon-button.active {
        background-color: #e2e6ea;
      }
      .material-symbols-outlined {
        vertical-align: middle;
        font-size: 20px;
      }

      .action-button {
        background-color: var(--bg-color);
        border: 1px solid var(--border-color);
        padding: 6px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .action-button.primary {
        background-color: var(--primary-color);
        color: white;
      }
      .action-button.danger {
        background-color: #dc3545;
        color: white;
      }

      .sidebar-section {
        padding: 15px;
        border-bottom: 1px solid var(--border-color);
      }
      .collapsible-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
      }
      .collapsible-header h3 {
        margin: 0;
        font-size: 1rem;
        user-select: none;
      }
      .collapse-icon {
        transition: transform 0.3s ease;
        user-select: none;
      }
      .collapsible-content {
        max-height: 500px;
        overflow-y: hidden;
        transition: max-height 0.3s ease-out;
        padding-top: 10px;
      }
      .collapsed .collapsible-content {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        margin-top: -15px;
      }
      .collapsed .collapse-icon {
        transform: rotate(-90deg);
      }

      #filter-input {
        width: 100%;
        box-sizing: border-box;
        padding: 8px 10px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 14px;
      }
      #filter-results-count {
        font-size: 12px;
        color: #6c757d;
        margin-top: 8px;
      }
      .list-container {
        overflow-y: auto;
        max-height: 20vh;
      }
      .list-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .list-item:hover,
      .list-item.selected {
        background-color: #e9ecef;
      }
      .list-item img,
      .list-item .item-icon {
        width: 40px;
        height: 40px;
        object-fit: cover;
        border-radius: 4px;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: var(--primary-color);
        background-color: var(--border-color);
      }
      .list-item .info {
        font-size: 13px;
        line-height: 1.3;
        overflow: hidden;
        flex-grow: 1;
      }
      .list-item .filename {
        font-weight: 600;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .list-item .details {
        font-size: 11px;
        color: #6c757d;
      }
      .locate-button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 4px;
        cursor: pointer;
      }

      .user-message {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2000;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: var(--shadow);
        font-size: 14px;
        text-align: center;
        max-width: 80%;
        pointer-events: none;
      }
      .user-message.error {
        background: rgba(220, 53, 69, 0.9);
      }
      .user-message.info {
        background: rgba(13, 110, 253, 0.9);
      }
      #drop-zone {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 123, 255, 0.1);
        border: 3px dashed var(--primary-color);
        z-index: 9999;
        display: none;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }
      #drop-zone.visible {
        display: flex;
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 3000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
        justify-content: center;
        align-items: center;
      }
      .modal-content {
        background-color: #fefefe;
        margin: auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 500px;
        border-radius: 8px;
        box-shadow: var(--shadow);
      }
      .close-button {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
      }
      .modal-buttons {
        text-align: right;
        margin-top: 20px;
      }

      #image-viewer-modal .modal-content {
        width: 90vw;
        height: 90vh;
        padding: 10px;
        background: #333;
      }
      #image-viewer-modal img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      #image-viewer-modal .close-button {
        position: absolute;
        top: 15px;
        right: 35px;
        color: white;
        font-size: 40px;
      }

      .custom-div-icon {
        background: none;
        border: none;
      }
      .thumbnail-tooltip {
        background: transparent;
        border: none;
        box-shadow: none;
      }
      .thumbnail-tooltip img,
      .thumbnail-tooltip .item-icon-map {
        width: 80px;
        height: 80px;
        object-fit: cover;
        border: 2px solid white;
        border-radius: 4px;
        box-shadow: var(--shadow);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        font-weight: bold;
        color: var(--primary-color);
        background-color: var(--white);
      }
    </style>
  </head>
  <body>
    <!-- HEADER -->
    <header id="header">
      <div class="header-left">
        <button id="sidebar-toggle" class="icon-button" title="Toggle Sidebar">
          <span class="material-symbols-outlined">menu</span>
        </button>
        <div class="logo">Dioptra<span>Spy</span></div>
      </div>
      <div class="header-right">
        <button id="add-image-btn" class="icon-button" title="Add Image">
          <span class="material-symbols-outlined">add_photo_alternate</span>
        </button>
        <button id="add-note-btn" class="icon-button" title="Add Note">
          <span class="material-symbols-outlined">note_add</span>
        </button>
        <button id="add-person-btn" class="icon-button" title="Add Person">
          <span class="material-symbols-outlined">person_add</span>
        </button>
        <button id="add-vehicle-btn" class="icon-button" title="Add Vehicle">
          <span class="material-symbols-outlined">directions_car</span>
        </button>
        <span
          style="border-left: 1px solid var(--border-color); height: 25px"
        ></span>
        <button
          id="toggle-thumbnails-btn"
          class="icon-button"
          title="Toggle All Thumbnails"
        >
          <span class="material-symbols-outlined">imagesmode</span>
        </button>
        <button
          id="measure-tool-btn"
          class="icon-button"
          title="Measure Distance"
        >
          <span class="material-symbols-outlined">straighten</span>
        </button>
        <button
          id="range-tool-btn"
          class="icon-button"
          title="Draw Range Circle"
        >
          <span class="material-symbols-outlined">public</span>
        </button>
        <button
          id="add-connection-btn"
          class="icon-button"
          title="Add Connection"
        >
          <span class="material-symbols-outlined">link</span>
        </button>
        <span
          style="border-left: 1px solid var(--border-color); height: 25px"
        ></span>
        <button class="action-button" id="export-html-btn">
          <span class="material-symbols-outlined">download</span> Export
        </button>
        <button class="action-button" id="save-session-btn">
          <span class="material-symbols-outlined">save</span> Save
        </button>
        <button class="action-button" id="load-session-btn">
          <span class="material-symbols-outlined">folder_open</span> Load
        </button>
      </div>
    </header>

    <!-- SIDEBAR -->
    <aside id="sidebar"></aside>

    <!-- INSPECTOR -->
    <aside id="inspector">
      <div id="inspector-content">
        <div id="inspector-placeholder">
          Select an item, connection, or tool to see its details.
        </div>

        <div id="inspector-item-details" style="display: none">
          <img id="details-thumbnail" src="" alt="Selected item thumbnail" />
          <div
            id="details-icon"
            class="item-icon"
            style="
              display: none;
              font-size: 48px;
              height: 80px;
              width: 80px;
              margin: 0 auto 20px auto;
              border-radius: 8px;
            "
          ></div>
          <div class="inspector-group">
            <label for="details-title">Title</label
            ><input type="text" id="details-title" />
          </div>
          <div class="inspector-group" data-type="vehicle">
            <label for="details-vehicle-type">Vehicle Type</label
            ><input
              type="text"
              id="details-vehicle-type"
              placeholder="Car, motorcycle, boat..."
            />
          </div>
          <div class="inspector-group">
            <label for="details-date">Date</label
            ><input type="text" id="details-date" placeholder="DD/MM/YYYY" />
          </div>
          <div class="inspector-group">
            <label for="details-time">Time</label
            ><input type="text" id="details-time" placeholder="HH:MM:SS" />
          </div>
          <div class="inspector-group">
            <label for="details-tags">Tags (comma-separated)</label
            ><input type="text" id="details-tags" />
          </div>
          <div class="inspector-group">
            <label for="details-latitude">Latitude</label
            ><input type="number" id="details-latitude" step="any" />
          </div>
          <div class="inspector-group">
            <label for="details-longitude">Longitude</label
            ><input type="number" id="details-longitude" step="any" />
          </div>
          <div class="inspector-group">
            <label for="details-notes">Notes</label
            ><textarea id="details-notes"></textarea>
          </div>
          <button
            class="action-button"
            id="street-view-btn"
            style="width: 100%; margin-bottom: 10px"
          >
            <span class="material-symbols-outlined">travel_explore</span> View
            in Street View
          </button>
          <button
            class="action-button danger"
            id="delete-item-btn"
            style="width: 100%"
          >
            <span class="material-symbols-outlined">delete</span> Delete Item
          </button>
        </div>

        <div id="inspector-connection-details" style="display: none">
          <h3>Connection Details</h3>
          <div class="inspector-group">
            <label for="connection-label">Label</label
            ><input type="text" id="connection-label" />
          </div>
          <div class="inspector-group">
            <label for="connection-notes">Notes</label
            ><textarea id="connection-notes"></textarea>
          </div>
          <div class="inspector-group">
            <label for="connection-color-picker">Line Color</label
            ><input type="color" id="connection-color-picker" />
          </div>
          <button class="action-button danger" id="delete-connection-btn">
            <span class="material-symbols-outlined">delete</span> Delete
            Connection
          </button>
        </div>

        <div id="inspector-tool-details" style="display: none">
          <h3>Tool Details</h3>
          <div class="inspector-group">
            <label for="tool-label">Label</label
            ><input type="text" id="tool-label" />
          </div>
          <div id="tool-measure-info">
            <div class="inspector-group">
              <label>Total Distance</label
              ><input type="text" id="tool-measure-distance" readonly />
            </div>
          </div>
          <div id="tool-range-info">
            <div class="inspector-group">
              <label for="tool-range-radius">Radius (km)</label
              ><input type="number" id="tool-range-radius" step="0.1" />
            </div>
            <div class="inspector-group">
              <label for="tool-range-color">Color</label
              ><input type="color" id="tool-range-color" />
            </div>
          </div>
          <div class="inspector-group">
            <label for="tool-notes">Notes</label
            ><textarea id="tool-notes"></textarea>
          </div>
          <div class="inspector-group">
            <label for="tool-tags">Tags (comma-separated)</label
            ><input type="text" id="tool-tags" />
          </div>
          <button
            class="action-button danger"
            id="delete-tool-btn"
            style="width: 100%"
          >
            <span class="material-symbols-outlined">delete</span> Delete Tool
          </button>
        </div>
      </div>
    </aside>

    <!-- MAIN CONTENT AREA -->
    <main id="main-content">
      <div id="map"></div>
      <div id="drop-zone"><div id="drop-zone-text">Drop Images Here</div></div>
    </main>

    <!-- MODALS -->
    <div id="manual-geo-modal" class="modal">
      <div class="modal-content">
        <span class="close-button">&times;</span>
        <h2>Manually Enter Coordinates</h2>
        <p id="modal-item-name"></p>
        <div class="inspector-group">
          <label for="modal-latitude">Latitude</label
          ><input type="number" id="modal-latitude" step="any" />
        </div>
        <div class="inspector-group">
          <label for="modal-longitude">Longitude</label
          ><input type="number" id="modal-longitude" step="any" />
        </div>
        <div class="modal-buttons">
          <button class="action-button" id="modal-cancel-btn">Cancel</button>
          <button class="action-button" id="modal-place-manually-btn">
            Place on Map
          </button>
          <button class="action-button primary" id="modal-save-btn">
            Save Coordinates
          </button>
        </div>
      </div>
    </div>
    <div id="image-viewer-modal" class="modal">
      <span class="close-button">&times;</span>
      <div class="modal-content">
        <img id="image-viewer-src" src="" alt="Full size image" />
      </div>
    </div>

    <script>
      /* DioptraSpy
 * Copyright (C) 2025 Kanarath
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
      document.addEventListener("DOMContentLoaded", function () {
        // STATE VARIABLES
        let currentImageData = [];
        let itemPendingPlacement = null;
        let connectionPendingPlacement = {
          active: false,
          firstPoint: null,
          line: null,
        };
        let connectionsData = [];
        let toolsData = [];

        let selectedItemId = null;
        let selectedConnectionId = null;
        let selectedToolId = null;

        let activeTool = null;
        let measureState = { points: [], line: null, markers: [] };
        let isThumbnailViewActive = false;

        // UI ELEMENT MAPPING
        const ui = {
          sidebar: document.getElementById("sidebar"),
          sidebarToggle: document.getElementById("sidebar-toggle"),
          saveBtn: document.getElementById("save-session-btn"),
          loadBtn: document.getElementById("load-session-btn"),
          addImgBtn: document.getElementById("add-image-btn"),
          addNoteBtn: document.getElementById("add-note-btn"),
          addPersonBtn: document.getElementById("add-person-btn"),
          addVehicleBtn: document.getElementById("add-vehicle-btn"),
          addConnectionBtn: document.getElementById("add-connection-btn"),
          toggleThumbnailsBtn: document.getElementById("toggle-thumbnails-btn"),
          measureToolBtn: document.getElementById("measure-tool-btn"),
          rangeToolBtn: document.getElementById("range-tool-btn"),
          exportHtmlBtn: document.getElementById("export-html-btn"),
          dropZone: document.getElementById("drop-zone"),
          mainContent: document.getElementById("main-content"),
          map: document.getElementById("map"),

          inspector: document.getElementById("inspector"),
          inspectorPlaceholder: document.getElementById(
            "inspector-placeholder"
          ),
          inspectorItemDetails: document.getElementById(
            "inspector-item-details"
          ),
          inspectorConnectionDetails: document.getElementById(
            "inspector-connection-details"
          ),
          inspectorToolDetails: document.getElementById(
            "inspector-tool-details"
          ),

          detailsThumbnail: document.getElementById("details-thumbnail"),
          detailsIcon: document.getElementById("details-icon"),
          detailsTitle: document.getElementById("details-title"),
          detailsVehicleType: document.getElementById("details-vehicle-type"),
          detailsDate: document.getElementById("details-date"),
          detailsTime: document.getElementById("details-time"),
          detailsTags: document.getElementById("details-tags"),
          detailsLatitude: document.getElementById("details-latitude"),
          detailsLongitude: document.getElementById("details-longitude"),
          detailsNotes: document.getElementById("details-notes"),
          streetViewBtn: document.getElementById("street-view-btn"),
          deleteItemBtn: document.getElementById("delete-item-btn"),

          connectionLabel: document.getElementById("connection-label"),
          connectionNotes: document.getElementById("connection-notes"),
          connectionColorPicker: document.getElementById(
            "connection-color-picker"
          ),
          deleteConnectionBtn: document.getElementById("delete-connection-btn"),

          toolLabel: document.getElementById("tool-label"),
          toolMeasureInfo: document.getElementById("tool-measure-info"),
          toolMeasureDistance: document.getElementById("tool-measure-distance"),
          toolRangeInfo: document.getElementById("tool-range-info"),
          toolRangeRadius: document.getElementById("tool-range-radius"),
          toolRangeNotes: document.getElementById("tool-range-notes"),
          toolRangeTags: document.getElementById("tool-range-tags"),
          toolRangeColor: document.getElementById("tool-range-color"),
          toolNotes: document.getElementById("tool-notes"),
          toolTags: document.getElementById("tool-tags"),
          deleteToolBtn: document.getElementById("delete-tool-btn"),

          manualGeoModal: document.getElementById("manual-geo-modal"),
          modalCloseBtn: document.querySelector(
            "#manual-geo-modal .close-button"
          ),
          modalLatitude: document.getElementById("modal-latitude"),
          modalLongitude: document.getElementById("modal-longitude"),
          modalCancelBtn: document.getElementById("modal-cancel-btn"),
          modalSaveBtn: document.getElementById("modal-save-btn"),
          modalPlaceManuallyBtn: document.getElementById(
            "modal-place-manually-btn"
          ),
          modalItemName: document.getElementById("modal-item-name"),

          imageViewerModal: document.getElementById("image-viewer-modal"),
          imageViewerSrc: document.getElementById("image-viewer-src"),
          imageViewerCloseBtn: document.querySelector(
            "#image-viewer-modal .close-button"
          ),
        };

        // MAP INITIALIZATION
        const map = L.map(ui.map, { zoomControl: false }).setView([20, 0], 2);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "&copy; OpenStreetMap",
        }).addTo(map);
        L.control.zoom({ position: "bottomright" }).addTo(map);
        const markersLayer = L.markerClusterGroup();
        const connectionsLayer = L.layerGroup().addTo(map);
        const toolsLayer = L.layerGroup().addTo(map);
        const thumbnailLayer = L.layerGroup();
        map.addLayer(markersLayer);

        // CUSTOM ICONS
        const personIcon = L.divIcon({
          className: "custom-div-icon",
          html: `<span class="material-symbols-outlined" style="font-size: 32px; color: #000000;">person</span>`,
          iconSize: [32, 32],
          iconAnchor: [16, 32],
        });
        const vehicleIcon = L.divIcon({
          className: "custom-div-icon",
          html: `<span class="material-symbols-outlined" style="font-size: 32px; color: #000000;">directions_car</span>`,
          iconSize: [32, 32],
          iconAnchor: [16, 32],
        });
        const noteIcon = L.divIcon({
          className: "custom-div-icon",
          html: `<span class="material-symbols-outlined" style="font-size: 32px; color: #000000;">note</span>`,
          iconSize: [32, 32],
          iconAnchor: [16, 32],
        });

        // APP KICK-OFF
        setupEventListeners();
        setupSidebarHTML();
        loadInitialData();

        // ===================================================================================
        // EVENT LISTENERS & SETUP
        // ===================================================================================

        function setupEventListeners() {
          ui.sidebarToggle.addEventListener("click", () => {
            ui.sidebar.classList.toggle("open");
            setTimeout(() => map.invalidateSize(), 300);
          });
          ui.saveBtn.addEventListener("click", saveSession);
          ui.loadBtn.addEventListener("click", loadSession);
          ui.exportHtmlBtn.addEventListener("click", generateReportHTML);
          ui.addImgBtn.addEventListener("click", triggerFileUpload);
          ui.addNoteBtn.addEventListener("click", () =>
            startPinDrop(null, { type: "note", title: "New Note" })
          );
          ui.addPersonBtn.addEventListener("click", () =>
            startPinDrop(null, { type: "person", title: "New Person" })
          );
          ui.addVehicleBtn.addEventListener("click", () =>
            startPinDrop(null, { type: "vehicle", title: "New Vehicle" })
          );
          ui.toggleThumbnailsBtn.addEventListener("click", toggleThumbnailView);
          ui.addConnectionBtn.addEventListener("click", () =>
            toggleTool("connection")
          );
          ui.measureToolBtn.addEventListener("click", () =>
            toggleTool("measure")
          );
          ui.rangeToolBtn.addEventListener("click", () => toggleTool("range"));

          ui.inspector
            .querySelectorAll("input, textarea")
            .forEach((element) => {
              const handler = () => {
                if (selectedItemId) saveInspectorDetails(selectedItemId);
                if (selectedConnectionId)
                  saveConnectionDetails(selectedConnectionId);
                if (selectedToolId) saveToolDetails(selectedToolId);
              };
              if (
                element.id !== "details-latitude" &&
                element.id !== "details-longitude"
              ) {
                element.addEventListener("input", handler);
              }
            });
          ui.detailsLatitude.addEventListener("change", handleCoordinateChange);
          ui.detailsLongitude.addEventListener(
            "change",
            handleCoordinateChange
          );

          ui.deleteItemBtn.addEventListener("click", () => {
            if (
              selectedItemId &&
              confirm("Delete this item and all its connections?")
            )
              deleteItem(selectedItemId);
          });
          ui.streetViewBtn.addEventListener("click", () => {
            const item = currentImageData.find((i) => i.id === selectedItemId);
            if (item && item.isLocated)
              window.open(
                `https://www.google.com/maps?q&layer=c&cbll=${item.latitude},${item.longitude}`,
                "_blank"
              );
          });
          ui.detailsThumbnail.addEventListener("click", () => {
            const item = currentImageData.find((i) => i.id === selectedItemId);
            if (item && item.type === "image" && item.thumbnail_rel_path) {
              ui.imageViewerSrc.src = item.thumbnail_rel_path;
              ui.imageViewerModal.style.display = "flex";
            }
          });

          ui.deleteConnectionBtn.addEventListener("click", () => {
            if (selectedConnectionId && confirm("Delete this connection?"))
              deleteConnection(selectedConnectionId);
          });
          ui.deleteToolBtn.addEventListener("click", () => {
            if (selectedToolId && confirm("Delete this tool?"))
              deleteTool(selectedToolId);
          });

          ui.modalCloseBtn.addEventListener(
            "click",
            () => (ui.manualGeoModal.style.display = "none")
          );
          ui.modalCancelBtn.addEventListener(
            "click",
            () => (ui.manualGeoModal.style.display = "none")
          );
          ui.modalSaveBtn.addEventListener("click", handleModalSave);
          ui.modalPlaceManuallyBtn.addEventListener("click", () => {
            if (itemPendingPlacement) {
              ui.manualGeoModal.style.display = "none";
              startPinDrop(itemPendingPlacement.id);
            }
          });
          ui.imageViewerModal.addEventListener(
            "click",
            () => (ui.imageViewerModal.style.display = "none")
          );
          ui.imageViewerCloseBtn.addEventListener(
            "click",
            () => (ui.imageViewerModal.style.display = "none")
          );

          ui.mainContent.addEventListener("dragover", (e) => {
            e.preventDefault();
            ui.dropZone.classList.add("visible");
          });
          ui.mainContent.addEventListener("dragleave", (e) => {
            e.preventDefault();
            ui.dropZone.classList.remove("visible");
          });
          ui.mainContent.addEventListener("drop", (e) => {
            e.preventDefault();
            ui.dropZone.classList.remove("visible");
            if (e.dataTransfer.files.length > 0)
              processFiles(e.dataTransfer.files);
          });

          map.on("click", (e) => {
            if (
              e.originalEvent.target.closest(
                ".leaflet-marker-icon, .leaflet-interactive"
              )
            )
              return;

            if (activeTool === "connection") handleConnectionMapClick(e.latlng);
            else if (activeTool === "measure") handleMeasureClick(e);
            else if (activeTool === "range") handleRangeClick(e.latlng);
            else deselectAll();
          });
          map.on("mousemove", handleConnectionMouseMove);

          ["sidebar", "inspector"].forEach((id) => {
            document
              .getElementById(id)
              .addEventListener("transitionend", () => map.invalidateSize());
          });
        }

        // ===================================================================================
        // TOOL MANAGEMENT
        // ===================================================================================

        function toggleTool(toolName) {
          const btn = {
            connection: ui.addConnectionBtn,
            measure: ui.measureToolBtn,
            range: ui.rangeToolBtn,
          }[toolName];
          const isDeactivating = activeTool === toolName;

          if (activeTool) {
            const oldBtn = {
              connection: ui.addConnectionBtn,
              measure: ui.measureToolBtn,
              range: ui.rangeToolBtn,
            }[activeTool];
            oldBtn.classList.remove("active");
            map.getContainer().classList.remove(`${activeTool}-mode`);
            if (activeTool === "connection") finishConnectionMode(true);
            if (activeTool === "measure") clearMeasureTool(false);
          }
          activeTool = null;

          if (!isDeactivating) {
            activeTool = toolName;
            btn.classList.add("active");
            map.getContainer().classList.add(`${toolName}-mode`);
            let message = `${
              toolName.charAt(0).toUpperCase() + toolName.slice(1)
            } tool activated.`;
            if (toolName === "measure")
              message +=
                " Click to add points, double-click on last point to finish.";
            displayMessage(message, "info");
          } else {
            displayMessage(
              `${
                toolName.charAt(0).toUpperCase() + toolName.slice(1)
              } tool deactivated.`,
              "info"
            );
          }
        }

        function handleMeasureClick(e) {
          const latlng = e.latlng;
          measureState.points.push(latlng);
          const marker = L.circleMarker(latlng, {
            radius: 5,
            color: "red",
          }).addTo(toolsLayer);
          measureState.markers.push(marker);

          if (measureState.points.length > 1) {
            if (measureState.line) measureState.line.addLatLng(latlng);
            else
              measureState.line = L.polyline(measureState.points, {
                color: "red",
              }).addTo(toolsLayer);
          }

          if (measureState.points.length > 1) {
            const popupContent = `Distance: ${calculateDistance(
              measureState.points
            )} km`;
            if (measureState.markers.length > 1)
              measureState.markers[
                measureState.markers.length - 2
              ].closePopup();
            marker
              .bindPopup(popupContent, { closeButton: false, autoClose: false })
              .openPopup();
          }

          marker.on("dblclick", (ev) => {
            L.DomEvent.stop(ev);
            const newMeasureTool = {
              id: Date.now() + Math.random(),
              type: "measure",
              label: "New Measurement",
              points: [...measureState.points],
              line: measureState.line,
              markers: measureState.markers,
            };
            toolsData.push(newMeasureTool);
            addInteractionToMeasureTool(newMeasureTool);
            clearMeasureTool(true);
            displayMessage("Measurement saved.", "info");
            toggleTool("measure");
            updateUI();
          });
        }

        function addInteractionToMeasureTool(tool) {
          tool.markers.forEach((marker, index) => {
            marker.setZIndexOffset(1000);
          });
          tool.line.on("click", (e) => {
            L.DomEvent.stop(e);
            selectTool(tool.id);
          });
        }

        function calculateDistance(points) {
          let totalDistance = 0;
          for (let i = 0; i < points.length - 1; i++) {
            totalDistance += map.distance(points[i], points[i + 1]);
          }
          return (totalDistance / 1000).toFixed(2);
        }

        function clearMeasureTool(isFinished) {
          if (!isFinished) {
            if (measureState.line) toolsLayer.removeLayer(measureState.line);
            measureState.markers.forEach((m) => toolsLayer.removeLayer(m));
          }
          measureState = { points: [], line: null, markers: [] };
        }

        function handleRangeClick(latlng) {
          const radiusKm = parseFloat(
            prompt("Enter radius in kilometers:", "1")
          );
          if (radiusKm && radiusKm > 0) {
            const newRangeTool = {
              id: Date.now() + Math.random(),
              type: "range",
              label: "New Range",
              center: latlng,
              radius: radiusKm * 1000,
              notes: "",
              tags: [],
              color: "#0000FF",
            };
            const circle = L.circle(latlng, {
              radius: newRangeTool.radius,
              color: newRangeTool.color,
              fillOpacity: 0.1,
            });
            const marker = L.marker(latlng, { draggable: true });
            newRangeTool.layer = L.layerGroup([circle, marker]).addTo(
              toolsLayer
            );
            newRangeTool.circle = circle;
            newRangeTool.marker = marker;
            toolsData.push(newRangeTool);
            addInteractionToRangeTool(newRangeTool);
            displayMessage("Range tool created.", "info");
            updateUI();
          } else if (radiusKm !== null) {
            alert("Invalid radius.");
          }
          toggleTool("range");
        }

        function addInteractionToRangeTool(tool) {
          tool.marker.on("drag", () => {
            const newCenter = tool.marker.getLatLng();
            tool.center = newCenter;
            tool.circle.setLatLng(newCenter);
          });
          tool.layer.on("click", (e) => {
            L.DomEvent.stop(e);
            selectTool(tool.id);
          });
        }

        // ===================================================================================
        // ITEM & OBJECT MANAGEMENT (CREATE, DELETE, SELECT)
        // ===================================================================================

        function deleteItem(itemId) {
          const connectionsToDelete = connectionsData.filter((conn) =>
            conn.pinIds.includes(itemId)
          );
          connectionsToDelete.forEach((conn) =>
            deleteConnection(conn.id, true)
          );
          const item = currentImageData.find((i) => i.id === itemId);
          if (item && item.marker) markersLayer.removeLayer(item.marker);
          currentImageData = currentImageData.filter((i) => i.id !== itemId);
          deselectAll();
          updateUI();
          displayMessage("Item deleted.", "info");
        }

        function deleteConnection(connectionId, silent = false) {
          const conn = connectionsData.find((c) => c.id === connectionId);
          if (conn && conn.line) connectionsLayer.removeLayer(conn.line);
          connectionsData = connectionsData.filter(
            (c) => c.id !== connectionId
          );
          if (selectedConnectionId === connectionId) deselectAll();
          updateUI();
          if (!silent) displayMessage("Connection deleted.", "info");
        }

        function deleteTool(toolId) {
          const toolIndex = toolsData.findIndex((t) => t.id === toolId);
          if (toolIndex > -1) {
            const tool = toolsData[toolIndex];
            if (tool.layer) toolsLayer.removeLayer(tool.layer); // Range tool
            if (tool.line) toolsLayer.removeLayer(tool.line); // Measure tool
            if (tool.markers)
              tool.markers.forEach((m) => toolsLayer.removeLayer(m));
            toolsData.splice(toolIndex, 1);
          }
          deselectAll();
          updateUI();
          displayMessage("Tool deleted.", "info");
        }

        function handleModalSave() {
          if (!itemPendingPlacement) return;
          const lat = parseFloat(ui.modalLatitude.value);
          const lon = parseFloat(ui.modalLongitude.value);
          if (isNaN(lat) || isNaN(lon))
            return displayMessage("Invalid coordinates.", "error");

          itemPendingPlacement.latitude = lat;
          itemPendingPlacement.longitude = lon;
          itemPendingPlacement.isLocated = true;
          ui.manualGeoModal.style.display = "none";
          displayMessage(
            `Coordinates saved for ${itemPendingPlacement.title}.`,
            "info"
          );
          itemPendingPlacement = null;
          updateUI();
        }

        function getIconForItem(itemType) {
          return (
            { person: personIcon, vehicle: vehicleIcon, note: noteIcon }[
              itemType
            ] || new L.Icon.Default()
          );
        }

        function populateMap(imageData) {
          markersLayer.clearLayers();
          const geolocated = imageData.filter((item) => item.isLocated);
          geolocated.forEach((item) => {
            const marker = L.marker([item.latitude, item.longitude], {
              draggable: true,
              icon: getIconForItem(item.type),
            }).bindPopup(
              `<b>${item.title}</b><br><small>Click for details</small>`
            );
            marker.itemId = item.id;
            marker.on("click", (e) => {
              L.DomEvent.stopPropagation(e);
              if (activeTool === "connection")
                handleConnectionMarkerClick(item.id);
              else selectItem(item.id);
            });
            let originalPosition;
            marker.on("dragstart", function (e) {
              originalPosition = e.target.getLatLng();
            });
            marker.on("dragend", function (e) {
              const movedMarker = e.target;
              if (confirm("Move pin to new location?")) {
                const newPos = movedMarker.getLatLng();
                item.latitude = newPos.lat;
                item.longitude = newPos.lng;
                if (selectedItemId === item.id) {
                  ui.detailsLatitude.value = newPos.lat.toFixed(6);
                  ui.detailsLongitude.value = newPos.lng.toFixed(6);
                }
                updateConnectionLineVisuals(null, item.id);
                updateThumbnailView();
              } else {
                movedMarker.setLatLng(originalPosition);
              }
            });
            item.marker = marker;
            markersLayer.addLayer(marker);
          });
          updateThumbnailView();
        }

        function finishConnectionMode(cancel = false, message = "") {
          if (cancel && connectionPendingPlacement.line)
            connectionsLayer.removeLayer(connectionPendingPlacement.line);
          connectionPendingPlacement = {
            active: false,
            firstPoint: null,
            line: null,
          };
          if (message) displayMessage(message, "info");
        }

        function handleConnectionClick(type, data) {
          const endpoint =
            type === "pin"
              ? { type: "pin", id: data }
              : { type: "coordinate", latlng: data };
          if (!connectionPendingPlacement.firstPoint) {
            connectionPendingPlacement.firstPoint = endpoint;
            const latlng =
              type === "pin"
                ? currentImageData.find((i) => i.id === data).marker.getLatLng()
                : data;
            connectionPendingPlacement.line = L.polyline([latlng, latlng], {
              color: "#FF0000",
              weight: 6,
              dashArray: "10, 10",
            }).addTo(connectionsLayer);
            displayMessage(
              "Select the second pin or point on the map.",
              "info"
            );
          } else {
            const firstEndpoint = connectionPendingPlacement.firstPoint;
            if (
              firstEndpoint.type === "pin" &&
              endpoint.type === "pin" &&
              firstEndpoint.id === endpoint.id
            )
              return;
            const latlng1 =
              firstEndpoint.type === "pin"
                ? currentImageData
                    .find((i) => i.id === firstEndpoint.id)
                    .marker.getLatLng()
                : firstEndpoint.latlng;
            const latlng2 =
              endpoint.type === "pin"
                ? currentImageData
                    .find((i) => i.id === endpoint.id)
                    .marker.getLatLng()
                : endpoint.latlng;
            connectionPendingPlacement.line
              .setLatLngs([latlng1, latlng2])
              .setStyle({ dashArray: null });
            const newConnection = {
              id: Date.now() + Math.random(),
              endpoints: [firstEndpoint, endpoint],
              pinIds: [firstEndpoint, endpoint]
                .filter((e) => e.type === "pin")
                .map((e) => e.id),
              label: "",
              notes: "",
              color: "#FF0000",
            };
            newConnection.line = connectionPendingPlacement.line;
            newConnection.line.connectionId = newConnection.id;
            newConnection.line.on("click", (e) => {
              L.DomEvent.stopPropagation(e);
              selectConnection(newConnection.id);
            });
            connectionsData.push(newConnection);
            updateUI();
            finishConnectionMode(false, "Connection created.");
            toggleTool("connection");
          }
        }

        function handleConnectionMarkerClick(pinId) {
          handleConnectionClick("pin", pinId);
        }
        function handleConnectionMapClick(latlng) {
          handleConnectionClick("coordinate", latlng);
        }

        function handleConnectionMouseMove(e) {
          if (activeTool === "connection" && connectionPendingPlacement.line) {
            connectionPendingPlacement.line.setLatLngs([
              connectionPendingPlacement.line.getLatLngs()[0],
              e.latlng,
            ]);
          }
        }

        function updateConnectionLineVisuals(connId = null, movedPinId = null) {
          const connectionsToUpdate = connId
            ? [connectionsData.find((c) => c.id === connId)]
            : connectionsData;
          connectionsToUpdate.forEach((conn) => {
            if (!conn || !conn.line) return;
            conn.line.setStyle({ color: conn.color, weight: 6 });
            if (conn.pinIds.includes(movedPinId) || movedPinId) {
              const latlngs = conn.endpoints.map((endpoint) => {
                if (endpoint.type === "pin") {
                  const item = currentImageData.find(
                    (i) => i.id === endpoint.id
                  );
                  return item && item.marker ? item.marker.getLatLng() : null;
                }
                return L.latLng(endpoint.latlng.lat, endpoint.latlng.lng);
              });
              if (latlngs.every((ll) => ll)) conn.line.setLatLngs(latlngs);
            }
          });
        }

        function handlePinDrop(e) {
          if (!itemPendingPlacement) return;
          itemPendingPlacement.latitude = e.latlng.lat;
          itemPendingPlacement.longitude = e.latlng.lng;
          itemPendingPlacement.isLocated = true;
          finishPinDrop(`Item pin placed.`);
        }

        function finishPinDrop(message) {
          ui.map.classList.remove("pin-drop-mode");
          displayMessage(message, "info");
          document.removeEventListener("keydown", cancelPinDropOnEsc);
          itemPendingPlacement = null;
          updateUI();
        }

        function cancelPinDropOnEsc(e) {
          if (e.key === "Escape" && itemPendingPlacement) {
            if (!itemPendingPlacement.isLocated)
              currentImageData = currentImageData.filter(
                (i) => i.id !== itemPendingPlacement.id
              );
            finishPinDrop("Pin placement cancelled.");
          }
        }

        function startPinDrop(itemId, itemDetails = null) {
          if (itemPendingPlacement) return;
          if (itemId)
            itemPendingPlacement = currentImageData.find(
              (i) => i.id === itemId
            );
          else if (itemDetails) {
            const now = new Date();
            const dd = String(now.getDate()).padStart(2, "0"),
              mm = String(now.getMonth() + 1).padStart(2, "0"),
              yyyy = now.getFullYear();
            itemPendingPlacement = {
              id: Date.now() + Math.random(),
              type: itemDetails.type,
              title: itemDetails.title,
              isLocated: false,
              latitude: null,
              longitude: null,
              notes: "",
              tags: [],
              date: `${dd}/${mm}/${yyyy}`,
              time: now.toTimeString().split(" ")[0],
              ...(itemDetails.type === "vehicle" && { vehicleType: "" }),
            };
            currentImageData.push(itemPendingPlacement);
          }
          if (!itemPendingPlacement) return;
          ui.map.classList.add("pin-drop-mode");
          displayMessage(
            "Click map to place pin. Press ESC to cancel.",
            "info"
          );
          map.once("click", handlePinDrop);
          document.addEventListener("keydown", cancelPinDropOnEsc);
        }

        function selectItem(itemId) {
          deselectAll(true);
          selectedItemId = itemId;
          const item = currentImageData.find((i) => i.id === itemId);
          if (item) {
            ui.inspector.classList.add("open");
            ui.inspectorPlaceholder.style.display = "none";
            ui.inspectorConnectionDetails.style.display = "none";
            ui.inspectorToolDetails.style.display = "none";
            ui.inspectorItemDetails.style.display = "block";

            ui.inspectorItemDetails
              .querySelectorAll("[data-type]")
              .forEach((el) => (el.style.display = "none"));
            if (item.type === "vehicle")
              ui.inspectorItemDetails.querySelector(
                '[data-type="vehicle"]'
              ).style.display = "block";

            if (item.type === "image" && item.thumbnail_rel_path) {
              ui.detailsThumbnail.src = item.thumbnail_rel_path;
              ui.detailsThumbnail.style.display = "block";
              ui.detailsIcon.style.display = "none";
            } else {
              ui.detailsThumbnail.style.display = "none";
              ui.detailsIcon.style.display = "flex";
              ui.detailsIcon.innerHTML = `<span class="material-symbols-outlined">${
                { note: "note", person: "person", vehicle: "directions_car" }[
                  item.type
                ]
              }</span>`;
            }
            ui.detailsTitle.value = item.title || "";
            ui.detailsDate.value = item.date || "";
            ui.detailsTime.value = item.time || "";
            ui.detailsTags.value = (item.tags || []).join(", ");
            ui.detailsVehicleType.value = item.vehicleType || "";
            ui.detailsNotes.value = item.notes || "";
            ui.detailsLatitude.value = item.isLocated
              ? item.latitude.toFixed(6)
              : "";
            ui.detailsLongitude.value = item.isLocated
              ? item.longitude.toFixed(6)
              : "";
            if (item.marker) {
              map.flyTo(
                [item.latitude, item.longitude],
                map.getZoom() < 16 ? 16 : map.getZoom()
              );
              setTimeout(() => {
                if (item.marker) item.marker.openPopup();
              }, 400);
            }
          }
          updateUI();
        }

        function saveInspectorDetails(itemId) {
          const item = currentImageData.find((i) => i.id === itemId);
          if (item) {
            item.title = ui.detailsTitle.value;
            item.date = ui.detailsDate.value;
            item.time = ui.detailsTime.value;
            item.tags = ui.detailsTags.value
              .split(",")
              .map((t) => t.trim())
              .filter(Boolean);
            item.notes = ui.detailsNotes.value;
            if (item.type === "vehicle")
              item.vehicleType = ui.detailsVehicleType.value;
            updateUI();
          }
        }

        function handleCoordinateChange() {
          if (!selectedItemId) return;
          const item = currentImageData.find((i) => i.id === selectedItemId);
          const originalLat = item.latitude;
          const originalLon = item.longitude;
          const newLat = parseFloat(ui.detailsLatitude.value);
          const newLon = parseFloat(ui.detailsLongitude.value);
          if (isNaN(newLat) || isNaN(newLon)) {
            displayMessage("Invalid coordinate format.", "error");
            ui.detailsLatitude.value = originalLat.toFixed(6);
            ui.detailsLongitude.value = originalLon.toFixed(6);
            return;
          }
          if (
            confirm(
              `Move pin from [${originalLat.toFixed(4)}, ${originalLon.toFixed(
                4
              )}] to [${newLat.toFixed(4)}, ${newLon.toFixed(4)}]?`
            )
          ) {
            item.latitude = newLat;
            item.longitude = newLon;
            item.marker.setLatLng([newLat, newLon]);
            updateConnectionLineVisuals(null, item.id);
            updateThumbnailView();
            displayMessage("Pin location updated.", "info");
          } else {
            ui.detailsLatitude.value = originalLat.toFixed(6);
            ui.detailsLongitude.value = originalLon.toFixed(6);
          }
        }

        function setupSidebarHTML() {
          ui.sidebar.innerHTML = `<div class="sidebar-section"><input type="text" id="filter-input" placeholder="Filter by text or #tag"><div id="filter-results-count"></div></div><div class="sidebar-section collapsible" id="geolocated-section"><div class="collapsible-header"><h3>Geolocated Items</h3><span class="collapse-icon material-symbols-outlined">expand_less</span></div><div class="collapsible-content"><div id="geolocated-list" class="list-container"></div></div></div><div class="sidebar-section collapsible" id="unlocated-section"><div class="collapsible-header"><h3>Unlocated Items</h3><span class="collapse-icon material-symbols-outlined">expand_less</span></div><div class="collapsible-content"><div id="unlocated-list" class="list-container"></div></div></div><div class="sidebar-section collapsible" id="connections-section"><div class="collapsible-header"><h3>Connections</h3><span class="collapse-icon material-symbols-outlined">expand_less</span></div><div class="collapsible-content"><div id="connections-list" class="list-container"></div></div></div><div class="sidebar-section collapsible" id="tools-section"><div class="collapsible-header"><h3>Tools</h3><span class="collapse-icon material-symbols-outlined">expand_less</span></div><div class="collapsible-content"><div id="tools-list" class="list-container"></div></div></div><div class="sidebar-section collapsible" id="general-notes-section" style="flex-grow: 1; display: flex; flex-direction: column;"><div class="collapsible-header"><h3>General Case Notes</h3><span class="collapse-icon material-symbols-outlined">expand_less</span></div><div class="collapsible-content" style="flex-grow: 1; display: flex; flex-direction: column;"><textarea id="general-notes" style="flex-grow:1;"></textarea></div></div>`;
          ui.filterInput = document.getElementById("filter-input");
          ui.filterResultsCount = document.getElementById(
            "filter-results-count"
          );
          ui.geolocatedList = document.getElementById("geolocated-list");
          ui.unlocatedList = document.getElementById("unlocated-list");
          ui.connectionsList = document.getElementById("connections-list");
          ui.toolsList = document.getElementById("tools-list");
          ui.generalNotes = document.getElementById("general-notes");
          ui.filterInput.addEventListener("input", () => updateUI());
          setupCollapsibleSections();
        }

        function updateUI() {
          const filterValue = ui.filterInput.value.toLowerCase().trim();
          const isTagFilter = filterValue.startsWith("#");
          const filterTerm = isTagFilter
            ? filterValue.substring(1)
            : filterValue;
          const allData = [...currentImageData].sort((a, b) =>
            (a.title || "").localeCompare(b.title || "")
          );
          const filteredData = allData.filter((item) => {
            if (!filterTerm) return true;
            if (isTagFilter)
              return (item.tags || []).some((tag) =>
                tag.toLowerCase().includes(filterTerm)
              );
            return [
              item.title,
              item.notes,
              item.date,
              item.time,
              item.vehicleType,
            ]
              .join(" ")
              .toLowerCase()
              .includes(filterTerm);
          });
          populateMap(filteredData);
          populateSidebar(allData);
          populateConnectionsList();
          populateToolsList();
          if (filterTerm)
            ui.filterResultsCount.textContent = `Showing ${filteredData.length} of ${currentImageData.length} items.`;
          else
            ui.filterResultsCount.textContent = `Total items: ${currentImageData.length}`;
        }

        function populateSidebar(imageData) {
          ui.geolocatedList.innerHTML = "";
          ui.unlocatedList.innerHTML = "";
          imageData.forEach((item) => {
            const listItem = document.createElement("div");
            listItem.className = "list-item";
            if (item.id === selectedItemId) listItem.classList.add("selected");
            let iconHtml = "";
            switch (item.type) {
              case "image":
                iconHtml = `<img src="${item.thumbnail_rel_path}" alt="thumb">`;
                break;
              case "note":
                iconHtml = `<div class="item-icon"><span class="material-symbols-outlined">note</span></div>`;
                break;
              case "person":
                iconHtml = `<div class="item-icon"><span class="material-symbols-outlined">person</span></div>`;
                break;
              case "vehicle":
                iconHtml = `<div class="item-icon"><span class="material-symbols-outlined">directions_car</span></div>`;
                break;
            }
            const targetList = item.isLocated
              ? ui.geolocatedList
              : ui.unlocatedList;
            if (item.isLocated) {
              listItem.innerHTML = `${iconHtml}<div class="info"><div class="filename">${
                item.title
              }</div><div class="details">${item.date || ""}</div></div>`;
              listItem.addEventListener("click", (e) => {
                e.stopPropagation();
                selectItem(item.id);
              });
            } else {
              listItem.innerHTML = `${iconHtml}<div class="info"><div class="filename">${item.title}</div></div><button class="locate-button">Locate</button>`;
              listItem
                .querySelector(".locate-button")
                .addEventListener("click", (e) => {
                  e.stopPropagation();
                  showManualGeoModal(item);
                });
            }
            targetList.appendChild(listItem);
          });
        }

        async function processFiles(files) {
          for (const file of files) {
            if (!file.type.startsWith("image/")) continue;
            const now = new Date();
            const dd = String(now.getDate()).padStart(2, "0"),
              mm = String(now.getMonth() + 1).padStart(2, "0"),
              yyyy = now.getFullYear();
            const newItem = {
              id: Date.now() + Math.random(),
              type: "image",
              title: file.name,
              isLocated: false,
              latitude: null,
              longitude: null,
              notes: "",
              tags: [],
              date: `${dd}/${mm}/${yyyy}`,
              time: now.toTimeString().split(" ")[0],
              model: "N/A",
              thumbnail_rel_path: await createThumbnail(file),
            };
            try {
              const tags = await getExifData(file);
              const gps = getGpsData(tags);
              const exifDateStr = (tags.DateTimeOriginal || "")
                .replace(/:/g, "/")
                .replace(" ", "/");
              const exifDate =
                exifDateStr && !isNaN(new Date(exifDateStr).getTime())
                  ? new Date(exifDateStr)
                  : now;
              const edd = String(exifDate.getDate()).padStart(2, "0"),
                emm = String(exifDate.getMonth() + 1).padStart(2, "0"),
                eyyyy = exifDate.getFullYear();
              newItem.latitude = gps.lat;
              newItem.longitude = gps.lon;
              newItem.date = `${edd}/${emm}/${eyyyy}`;
              newItem.time = exifDate.toTimeString().split(" ")[0];
              newItem.model = tags.Model || "N/A";
              newItem.isLocated = true;
              currentImageData.push(newItem);
            } catch (error) {
              currentImageData.push(newItem);
              showManualGeoModal(newItem);
            }
          }
          updateUI();
        }

        function showManualGeoModal(item) {
          itemPendingPlacement = item;
          ui.modalItemName.textContent = `For item: ${item.title}`;
          ui.modalLatitude.value = "";
          ui.modalLongitude.value = "";
          ui.manualGeoModal.style.display = "flex";
        }

        function generateReportHTML() {
          let body = `<h1>Investigation Report</h1><h2>General Case Notes</h2><p>${ui.generalNotes.value.replace(
            /\n/g,
            "<br>"
          )}</p><hr><h2>Items (${currentImageData.length})</h2>`;
          currentImageData.forEach((item) => {
            body += `<div class="item"><h3>${item.title} (${item.type})</h3>`;
            if (item.type === "image" && item.thumbnail_rel_path)
              body += `<img src="${item.thumbnail_rel_path}" width="200"><br>`;
            body += `<strong>Date/Time:</strong> ${item.date || "N/A"} ${
              item.time || "N/A"
            }<br>`;
            if (item.isLocated)
              body += `<strong>Location:</strong> ${item.latitude.toFixed(
                6
              )}, ${item.longitude.toFixed(6)}<br>`;
            if (item.tags && item.tags.length > 0)
              body += `<strong>Tags:</strong> ${item.tags.join(", ")}<br>`;
            if (item.notes)
              body += `<strong>Notes:</strong><p>${item.notes.replace(
                /\n/g,
                "<br>"
              )}</p>`;
            body += `</div><hr>`;
          });
          const reportHTML = `<html><head><title>Dioptra Spy Report</title><style>body{font-family:sans-serif; margin: 2em;} .item{border-left: 3px solid #ccc; padding-left: 1em; margin-bottom: 2em; page-break-inside: avoid;}</style></head><body>${body}</body></html>`;
          const blob = new Blob([reportHTML], { type: "text/html" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `dioptra-report-${Date.now()}.html`;
          a.click();
          URL.revokeObjectURL(url);
        }

        function triggerFileUpload() {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.multiple = true;
          input.onchange = (e) => {
            if (e.target.files.length > 0) processFiles(e.target.files);
          };
          input.click();
        }
        function createThumbnail(file, maxWidth = 400, maxHeight = 400) {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              const img = new Image();
              img.onload = () => {
                const canvas = document.createElement("canvas");
                let { width, height } = img;
                if (width > height) {
                  if (width > maxWidth) {
                    height *= maxWidth / width;
                    width = maxWidth;
                  }
                } else {
                  if (height > maxHeight) {
                    width *= maxHeight / height;
                    height = maxHeight;
                  }
                }
                canvas.width = width;
                canvas.height = height;
                canvas.getContext("2d").drawImage(img, 0, 0, width, height);
                resolve(canvas.toDataURL("image/jpeg"));
              };
              img.src = e.target.result;
            };
            reader.readAsDataURL(file);
          });
        }
        function getExifData(file) {
          return new Promise((resolve, reject) => {
            EXIF.getData(file, function () {
              const tags = EXIF.getAllTags(this);
              if (!tags || Object.keys(tags).length === 0)
                reject(new Error("No EXIF data."));
              else resolve(tags);
            });
          });
        }
        function getGpsData(tags) {
          if (!tags.GPSLatitude || !tags.GPSLongitude)
            throw new Error("GPS data not found.");
          const latRef = tags.GPSLatitudeRef || "N";
          const lonRef = tags.GPSLongitudeRef || "E";
          const lat =
            (tags.GPSLatitude[0] +
              tags.GPSLatitude[1] / 60 +
              tags.GPSLatitude[2] / 3600) *
            (latRef === "S" ? -1 : 1);
          const lon =
            (tags.GPSLongitude[0] +
              tags.GPSLongitude[1] / 60 +
              tags.GPSLongitude[2] / 3600) *
            (lonRef === "W" ? -1 : 1);
          return { lat, lon };
        }
        function saveSession() {
          if (selectedItemId) saveInspectorDetails(selectedItemId);
          if (selectedConnectionId) saveConnectionDetails(selectedConnectionId);
          if (selectedToolId) saveToolDetails(selectedToolId);
          const sessionData = {
            version: "1.9",
            createdAt: new Date().toISOString(),
            imageData: currentImageData.map(
              ({ marker, tooltip, ...rest }) => rest
            ),
            connectionsData: connectionsData.map(({ line, ...rest }) => ({
              ...rest,
              endpoints: rest.endpoints.map((e) =>
                e.type === "coordinate"
                  ? {
                      type: "coordinate",
                      latlng: { lat: e.latlng.lat, lng: e.latlng.lng },
                    }
                  : e
              ),
            })),
            toolsData: toolsData.map((tool) => {
              if (tool.type === "measure") {
                const { line, markers, ...rest } = tool;
                return {
                  ...rest,
                  points: rest.points.map((p) => ({ lat: p.lat, lng: p.lng })),
                };
              }
              if (tool.type === "range") {
                const { layer, circle, marker, ...rest } = tool;
                return {
                  ...rest,
                  center: { lat: rest.center.lat, lng: rest.center.lng },
                };
              }
              return tool;
            }),
            generalNotes: ui.generalNotes.value,
          };
          const dataStr = JSON.stringify(sessionData, null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `dioptra-case-${new Date()
            .toISOString()
            .slice(0, 10)}.json`;
          a.click();
          URL.revokeObjectURL(url);
          displayMessage("Session saved.", "info");
        }
        function loadSession() {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".json";
          input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                const data = JSON.parse(event.target.result);
                if (!data.imageData) throw new Error("Invalid session file.");
                loadSessionData(data);
                displayMessage("Session loaded.", "info");
              } catch (err) {
                displayMessage(`Error reading file: ${err.message}`, "error");
              }
            };
            reader.readAsText(file);
          };
          input.click();
        }
        function loadSessionData(sessionData) {
          currentImageData = sessionData.imageData || [];
          connectionsData = sessionData.connectionsData || [];
          toolsData = sessionData.toolsData || [];
          ui.generalNotes.value = sessionData.generalNotes || "";
          ui.filterInput.value = "";
          connectionsLayer.clearLayers();
          toolsLayer.clearLayers();
          connectionsData.forEach((conn) => {
            const latlngs = conn.endpoints
              .map((e) => {
                if (e.type === "pin") {
                  const item = currentImageData.find((i) => i.id === e.id);
                  return item ? L.latLng(item.latitude, item.longitude) : null;
                }
                return L.latLng(e.latlng.lat, e.latlng.lng);
              })
              .filter(Boolean);
            if (latlngs.length === 2) {
              const line = L.polyline(latlngs, {
                color: conn.color,
                weight: 6,
              }).addTo(connectionsLayer);
              line.connectionId = conn.id;
              line.on("click", (e) => {
                L.DomEvent.stopPropagation(e);
                selectConnection(conn.id);
              });
              conn.line = line;
            }
          });
          toolsData.forEach((tool) => {
            if (tool.type === "measure") {
              tool.points = tool.points.map((p) => L.latLng(p.lat, p.lng));
              tool.line = L.polyline(tool.points, { color: "red" }).addTo(
                toolsLayer
              );
              tool.markers = tool.points.map((p) =>
                L.circleMarker(p, { radius: 5, color: "red" }).addTo(toolsLayer)
              );
              addInteractionToMeasureTool(tool);
            }
            if (tool.type === "range") {
              tool.center = L.latLng(tool.center.lat, tool.center.lng);
              tool.circle = L.circle(tool.center, {
                radius: tool.radius,
                color: tool.color,
                fillOpacity: 0.1,
              });
              tool.marker = L.marker(tool.center, { draggable: true });
              tool.layer = L.layerGroup([tool.circle, tool.marker]).addTo(
                toolsLayer
              );
              addInteractionToRangeTool(tool);
            }
          });
          deselectAll();
          updateUI();
        }
        function deselectAll(silent = false) {
          if (selectedItemId) {
            if (!silent) saveInspectorDetails(selectedItemId);
            selectedItemId = null;
          }
          if (selectedConnectionId) {
            if (!silent) saveConnectionDetails(selectedConnectionId);
            selectedConnectionId = null;
          }
          if (selectedToolId) {
            if (!silent) saveToolDetails(selectedToolId);
            selectedToolId = null;
          }
          ui.inspector.classList.remove("open");
          ui.inspectorItemDetails.style.display = "none";
          ui.inspectorConnectionDetails.style.display = "none";
          ui.inspectorToolDetails.style.display = "none";
          ui.inspectorPlaceholder.style.display = "block";
          updateUI();
        }
        function selectConnection(id) {
          deselectAll(true);
          selectedConnectionId = id;
          const conn = connectionsData.find((c) => c.id === id);
          if (conn) {
            ui.inspector.classList.add("open");
            ui.inspectorPlaceholder.style.display = "none";
            ui.inspectorItemDetails.style.display = "none";
            ui.inspectorToolDetails.style.display = "none";
            ui.inspectorConnectionDetails.style.display = "block";
            ui.connectionLabel.value = conn.label || "";
            ui.connectionNotes.value = conn.notes || "";
            ui.connectionColorPicker.value = conn.color || "#FF0000";
          }
          updateUI();
        }
        function saveConnectionDetails(id) {
          const conn = connectionsData.find((c) => c.id === id);
          if (conn) {
            conn.label = ui.connectionLabel.value;
            conn.notes = ui.connectionNotes.value;
            conn.color = ui.connectionColorPicker.value;
            updateConnectionLineVisuals(id);
            updateUI();
          }
        }
        function selectTool(id) {
          deselectAll(true);
          selectedToolId = id;
          let tool = toolsData.find((t) => t.id === id);
          if (tool) {
            ui.inspector.classList.add("open");
            ui.inspectorPlaceholder.style.display = "none";
            ui.inspectorItemDetails.style.display = "none";
            ui.inspectorConnectionDetails.style.display = "none";
            ui.inspectorToolDetails.style.display = "block";
            if (tool.type === "measure") {
              ui.toolMeasureInfo.style.display = "block";
              ui.toolRangeInfo.style.display = "none";
              ui.toolMeasureDistance.value =
                calculateDistance(tool.points) + " km";
            } else {
              ui.toolMeasureInfo.style.display = "none";
              ui.toolRangeInfo.style.display = "block";
              ui.toolRangeRadius.value = (tool.radius / 1000).toFixed(2);
              ui.toolRangeNotes.value = tool.notes || "";
              ui.toolRangeTags.value = (tool.tags || []).join(", ");
              ui.toolRangeColor.value = tool.color || "#0000FF";
            }
            ui.toolLabel.value = tool.label || "";
            ui.toolNotes.value = tool.notes || "";
            ui.toolTags.value = (tool.tags || []).join(", ");
          }
          updateUI();
        }
        function saveToolDetails(id) {
          let tool = toolsData.find((t) => t.id === id);
          if (tool) {
            tool.label = ui.toolLabel.value;
            tool.notes = ui.toolNotes.value;
            tool.tags = ui.toolTags.value
              .split(",")
              .map((t) => t.trim())
              .filter(Boolean);
            if (tool.type === "range") {
              tool.radius = parseFloat(ui.toolRangeRadius.value) * 1000;
              tool.color = ui.toolRangeColor.value;
              tool.circle.setRadius(tool.radius);
              tool.circle.setStyle({ color: tool.color });
            }
            updateUI();
          }
        }
        function toggleThumbnailView() {
          isThumbnailViewActive = !isThumbnailViewActive;
          ui.toggleThumbnailsBtn.classList.toggle(
            "active",
            isThumbnailViewActive
          );
          updateThumbnailView();
        }
        function updateThumbnailView() {
          thumbnailLayer.clearLayers();
          if (!isThumbnailViewActive) {
            if (map.hasLayer(thumbnailLayer)) map.removeLayer(thumbnailLayer);
            return;
          }
          currentImageData
            .filter((item) => item.isLocated)
            .forEach((item) => {
              let content;
              if (item.type === "image")
                content = `<img src="${item.thumbnail_rel_path}" alt="thumb">`;
              else
                content = `<div class="item-icon-map"><span class="material-symbols-outlined">${
                  { note: "note", person: "person", vehicle: "directions_car" }[
                    item.type
                  ]
                }</span></div>`;
              const tooltip = L.tooltip({
                permanent: true,
                direction: "center",
                className: "thumbnail-tooltip",
              })
                .setLatLng([item.latitude, item.longitude])
                .setContent(content);
              item.tooltip = tooltip;
              thumbnailLayer.addLayer(tooltip);
            });
          if (!map.hasLayer(thumbnailLayer)) map.addLayer(thumbnailLayer);
        }
        function setupCollapsibleSections() {
          const savedState =
            JSON.parse(localStorage.getItem("dioptraSidebarState")) || {};
          ui.sidebar.addEventListener("click", (e) => {
            const header = e.target.closest(".collapsible-header");
            if (header) {
              const section = header.closest(".sidebar-section.collapsible");
              if (section) {
                section.classList.toggle("collapsed");
                savedState[section.id] =
                  section.classList.contains("collapsed");
                localStorage.setItem(
                  "dioptraSidebarState",
                  JSON.stringify(savedState)
                );
              }
            }
          });
          document
            .querySelectorAll(".sidebar-section.collapsible")
            .forEach((section) => {
              if (savedState[section.id] === true)
                section.classList.add("collapsed");
            });
        }
        function populateConnectionsList() {
          ui.connectionsList.innerHTML = "";
          connectionsData.forEach((conn) => {
            const listItem = document.createElement("div");
            listItem.className = "list-item";
            if (conn.id === selectedConnectionId)
              listItem.classList.add("selected");
            const label =
              conn.label || `Connection #${String(conn.id).slice(-4)}`;
            listItem.innerHTML = `<div class="color-box" style="background-color: ${conn.color};"></div><div class="info">${label}</div>`;
            listItem.addEventListener("click", () => selectConnection(conn.id));
            ui.connectionsList.appendChild(listItem);
          });
        }
        function populateToolsList() {
          ui.toolsList.innerHTML = "";
          toolsData.forEach((tool) => {
            const listItem = document.createElement("div");
            listItem.className = "list-item";
            if (tool.id === selectedToolId) listItem.classList.add("selected");
            const icon = tool.type === "measure" ? "straighten" : "public";
            const label =
              tool.label ||
              `${
                tool.type.charAt(0).toUpperCase() + tool.type.slice(1)
              } #${String(tool.id).slice(-4)}`;
            listItem.innerHTML = `<div class="item-icon"><span class="material-symbols-outlined">${icon}</span></div><div class="info">${label}</div>`;
            listItem.addEventListener("click", () => selectTool(tool.id));
            ui.toolsList.appendChild(listItem);
          });
        }
        function loadInitialData() {
          fetch("output/data.json")
            .then((response) => {
              if (response.ok) return response.json();
              else return Promise.resolve([]);
            })
            .then((data) => {
              if (data && data.length > 0) {
                const initialImageData = data.map((item) => {
                  const now = new Date();
                  const dd = String(now.getDate()).padStart(2, "0"),
                    mm = String(now.getMonth() + 1).padStart(2, "0"),
                    yyyy = now.getFullYear();
                  const dt = item.datetime ? item.datetime.split(" ") : [];
                  const date = dt[0]
                    ? dt[0].replace(/:/g, "/")
                    : `${dd}/${mm}/${yyyy}`;
                  const time = dt[1] || now.toTimeString().split(" ")[0];
                  return {
                    ...item,
                    id: Date.now() + Math.random(),
                    type: "image",
                    title: item.original_path.split(/[\\/]/).pop(),
                    notes: "",
                    tags: [],
                    date,
                    time,
                    isLocated: true,
                  };
                });
                loadSessionData({ imageData: initialImageData });
                displayMessage(`${data.length} initial items loaded.`, "info");
              } else {
                displayMessage(
                  "Ready. Add items or load a session file.",
                  "info"
                );
              }
            })
            .catch((error) => {
              console.error("Error loading initial data:", error);
              displayMessage(
                "Could not load initial data. Check console for errors. This may be due to browser security policies for local files. Try using a local server.",
                "error"
              );
            });
        }
        function displayMessage(message, type = "info", duration = 4000) {
          const existingMsg = document.querySelector(".user-message");
          if (existingMsg) existingMsg.remove();
          const msgDiv = document.createElement("div");
          msgDiv.className = `user-message ${type}`;
          msgDiv.innerHTML = message;
          ui.mainContent.appendChild(msgDiv);
          setTimeout(() => {
            if (msgDiv.parentElement) msgDiv.remove();
          }, duration);
        }
      });
    </script>
  </body>
</html>
